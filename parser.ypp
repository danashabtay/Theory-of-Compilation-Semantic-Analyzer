%{
#include "output.hpp"
extern int yylex();
using namespace output;
using namespace std;
void yyerror(const char *s);
extern int yylineno;

%}



%token TYPE
%token ID
%token SC
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token CALL
%token INT
%token BYTE
%token BOOL
%token NUM
%token B
%token STRING
%token TRUE
%token FALSE

%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELATIONAL
%left ADD_AND_SUB
%left MULT_AND_DIV
%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE





%%

Program : Statements { printProductionRule(1); }
;

Statements : Statement { printProductionRule(2); }
            | Statements Statement { printProductionRule(3); }
;

Statement : LBRACE Statements RBRACE { printProductionRule(4); }
            | Type ID SC { printProductionRule(5); }
            | Type ID ASSIGN Exp SC { printProductionRule(6); }
            | ID ASSIGN Exp SC { printProductionRule(7); }
            | Call SC { printProductionRule(8); }
            | RETURN SC { printProductionRule(9); }
            | IF LPAREN Exp RPAREN Statement { printProductionRule(10); }
            | IF LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(11); }
            | WHILE LPAREN Exp RPAREN Statement { printProductionRule(12); }
            | BREAK SC { printProductionRule(13); }
            | CONTINUE SC { printProductionRule(14); }
;

Call : ID LPAREN Exp RPAREN { printProductionRule(15); }
;

Type : INT { $$ = new Type("INT"); }
     | BYTE { $$ = new Type("BYTE"); }
     | BOOL { $$ = new Type("BOOL"); }
;

Exp : LPAREN Exp RPAREN { $$ = new Exp(dynamic_cast<Exp*>($2))}
    | Exp PLUS Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "arithmetic"); }
    | Exp MINUS Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "arithmetic"); }
    | Exp MULT Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "arithmetic"); }
    | Exp DIV Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "arithmetic"); }
    | ID { $$ = new Exp($1)}
    | Call { $$ = new Exp(dynamic_cast<Call*>($1)) }
    | NUM { $$ = new Exp("INT"); }
    | NUM B { $$ = new Exp("BYTE", $1); }
    | STRING { $$ = new Exp("STRING"); }
    | TRUE { $$ = new Exp("BOOL"); }
    | FALSE { $$ = new Exp("BOOL"); }
    | NOT Exp { $$ = new Exp(dynamic_cast<Exp*>($2), "logic"); }
    | Exp AND Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "logic"); }
    | Exp OR Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "logic"); }
    | Exp EQUALITYOP Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "relop"); }
    | Exp RELATIONALOP Exp { $$ = new Exp(dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3), "relop"); }
    | LPAREN Type RPAREN Exp { $$ = new Exp(dynamic_cast<Exp*>($4), dynamic_cast<Type*>($2)); }
    ;

%%

/* C code section */

int main() {
    return yyparse();
}

void yyerror(const char *s) {
    errorSyn(yylineno);
    exit(0);
}
